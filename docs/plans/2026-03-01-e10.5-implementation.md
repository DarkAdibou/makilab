# E10.5 ‚Äî Kanban CRUD + Activity Log + Chat UX ‚Äî Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Enrich the Mission Control dashboard with full CRUD tasks (tags, description, filters), an agent activity log, and improved chat streaming UX (token-by-token + tool call details).

**Architecture:** Three independent workstreams sharing the same SQLite DB layer and Fastify API. DB migrations first, then backend API, then frontend components. Each workstream is self-contained.

**Tech Stack:** Node.js 24, TypeScript, SQLite (node:sqlite), Fastify 5, Next.js 15, @dnd-kit, react-markdown, vanilla CSS.

---

## Task 1: DB Migration ‚Äî Add `description` and `tags` to tasks

**Files:**
- Modify: `packages/agent/src/memory/sqlite.ts:124-202` (add new migration)
- Modify: `packages/agent/src/memory/sqlite.ts:373-385` (update TaskRow interface)

**Step 1: Add migration function `migrateTasksAddDescriptionTags`**

After the existing `migrateTasksAddBacklog()` call at line 120, add:

```typescript
function migrateTasksAddDescriptionTags(db: DatabaseSync): void {
  db.exec(`
    CREATE TABLE IF NOT EXISTS _migrations (
      name       TEXT PRIMARY KEY,
      applied_at TEXT NOT NULL DEFAULT (datetime('now'))
    )
  `);
  const existing = db.prepare(
    "SELECT name FROM _migrations WHERE name = 'tasks_add_description_tags'"
  ).get();
  if (existing) return;

  // Check if columns already exist (fresh DB has them)
  const schema = (db.prepare(
    "SELECT sql FROM sqlite_master WHERE type='table' AND name='tasks'"
  ).get() as { sql: string } | undefined);

  if (schema?.sql.includes('description')) {
    db.prepare("INSERT INTO _migrations (name) VALUES ('tasks_add_description_tags')").run();
    return;
  }

  // Add columns via ALTER TABLE (safe for SQLite)
  db.exec("ALTER TABLE tasks ADD COLUMN description TEXT NOT NULL DEFAULT ''");
  db.exec("ALTER TABLE tasks ADD COLUMN tags TEXT NOT NULL DEFAULT '[]'");
  db.prepare("INSERT INTO _migrations (name) VALUES ('tasks_add_description_tags')").run();
}
```

**Step 2: Update the CREATE TABLE to include new columns for fresh DBs**

In the initial `CREATE TABLE IF NOT EXISTS tasks` (line 82-96), add after `cron_id`:
```sql
description TEXT NOT NULL DEFAULT '',
tags        TEXT NOT NULL DEFAULT '[]',
```

**Step 3: Update TaskRow interface**

Add to `TaskRow` (line 373-385):
```typescript
description: string;
tags: string; // JSON array string
```

**Step 4: Call the migration in initDb()**

After `repairTaskStepsFk(db);` (line 121), add:
```typescript
migrateTasksAddDescriptionTags(db);
```

**Step 5: Run tests to verify no regression**

Run: `cd "d:/SynologyDrive/IA et agents/makilab" && pnpm test`
Expected: All 35 tests pass.

**Step 6: Commit**

```bash
git add packages/agent/src/memory/sqlite.ts
git commit -m "feat(db): add description and tags columns to tasks table"
```

---

## Task 2: DB Migration ‚Äî Create `agent_events` table

**Files:**
- Modify: `packages/agent/src/memory/sqlite.ts` (add table creation + CRUD functions)

**Step 1: Add agent_events table to initDb()**

After the `task_steps` CREATE TABLE block (line 117), add:

```sql
CREATE TABLE IF NOT EXISTS agent_events (
  id          INTEGER PRIMARY KEY AUTOINCREMENT,
  type        TEXT NOT NULL CHECK(type IN ('tool_call','tool_result','message','error')),
  channel     TEXT NOT NULL,
  subagent    TEXT,
  action      TEXT,
  input       TEXT,
  output      TEXT,
  success     INTEGER,
  duration_ms INTEGER,
  created_at  TEXT NOT NULL DEFAULT (datetime('now'))
);
CREATE INDEX IF NOT EXISTS idx_agent_events_created ON agent_events(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_agent_events_type ON agent_events(type, created_at DESC);
```

**Step 2: Add `logAgentEvent()` function**

After `getStats()` (line ~515), add:

```typescript
export function logAgentEvent(event: {
  type: 'tool_call' | 'tool_result' | 'message' | 'error';
  channel: string;
  subagent?: string;
  action?: string;
  input?: unknown;
  output?: unknown;
  success?: boolean;
  durationMs?: number;
}): void {
  getDb().prepare(`
    INSERT INTO agent_events (type, channel, subagent, action, input, output, success, duration_ms)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
  `).run(
    event.type,
    event.channel,
    event.subagent ?? null,
    event.action ?? null,
    event.input ? JSON.stringify(event.input) : null,
    event.output ? JSON.stringify(event.output) : null,
    event.success !== undefined ? (event.success ? 1 : 0) : null,
    event.durationMs ?? null,
  );
}
```

**Step 3: Add `listAgentEvents()` function**

```typescript
export interface AgentEventRow {
  id: number;
  type: string;
  channel: string;
  subagent: string | null;
  action: string | null;
  input: string | null;
  output: string | null;
  success: number | null;
  duration_ms: number | null;
  created_at: string;
}

export function listAgentEvents(filter?: {
  type?: string;
  channel?: string;
  limit?: number;
}): AgentEventRow[] {
  let sql = 'SELECT * FROM agent_events WHERE 1=1';
  const params: (string | number)[] = [];
  if (filter?.type) { sql += ' AND type = ?'; params.push(filter.type); }
  if (filter?.channel) { sql += ' AND channel = ?'; params.push(filter.channel); }
  sql += ' ORDER BY created_at DESC LIMIT ?';
  params.push(filter?.limit ?? 100);
  return getDb().prepare(sql).all(...params) as unknown as AgentEventRow[];
}
```

**Step 4: Run tests**

Run: `cd "d:/SynologyDrive/IA et agents/makilab" && pnpm test`
Expected: All tests pass.

**Step 5: Commit**

```bash
git add packages/agent/src/memory/sqlite.ts
git commit -m "feat(db): add agent_events table for activity logging"
```

---

## Task 3: Backend API ‚Äî Enrich task endpoints + add DELETE + tags + activity

**Files:**
- Modify: `packages/agent/src/server.ts`
- Modify: `packages/agent/src/memory/sqlite.ts` (update `updateTask`, `createTask`, `listTasks`)

**Step 1: Update `createTask()` to accept `description` and `tags`**

In `sqlite.ts`, modify `createTask()` (line 402-426):

```typescript
export function createTask(params: {
  title: string;
  createdBy: 'user' | 'agent' | 'cron';
  channel: string;
  priority?: 'low' | 'medium' | 'high';
  context?: Record<string, unknown>;
  dueAt?: string;
  cronId?: string;
  description?: string;
  tags?: string[];
}): string {
  const id = randomUUID();
  getDb().prepare(`
    INSERT INTO tasks (id, title, created_by, channel, priority, context, due_at, cron_id, description, tags)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).run(
    id,
    params.title,
    params.createdBy,
    params.channel,
    params.priority ?? 'medium',
    JSON.stringify(params.context ?? {}),
    params.dueAt ?? null,
    params.cronId ?? null,
    params.description ?? '',
    JSON.stringify(params.tags ?? []),
  );
  return id;
}
```

**Step 2: Update `updateTask()` to accept `description`, `tags`, `due_at`**

In `sqlite.ts`, modify `updateTask()` (line 495-506):

```typescript
export function updateTask(id: string, fields: {
  status?: string;
  title?: string;
  priority?: string;
  description?: string;
  tags?: string[];
  due_at?: string | null;
}): TaskRow | null {
  const sets: string[] = [];
  const params: (string | null)[] = [];
  if (fields.status) { sets.push('status = ?'); params.push(fields.status); }
  if (fields.title) { sets.push('title = ?'); params.push(fields.title); }
  if (fields.priority) { sets.push('priority = ?'); params.push(fields.priority); }
  if (fields.description !== undefined) { sets.push('description = ?'); params.push(fields.description); }
  if (fields.tags !== undefined) { sets.push('tags = ?'); params.push(JSON.stringify(fields.tags)); }
  if (fields.due_at !== undefined) { sets.push('due_at = ?'); params.push(fields.due_at); }
  if (sets.length === 0) return getTask(id);
  sets.push("updated_at = datetime('now')");
  params.push(id);
  getDb().prepare(`UPDATE tasks SET ${sets.join(', ')} WHERE id = ?`).run(...params);
  return getTask(id);
}
```

**Step 3: Update `listTasks()` to support `tag`, `priority`, `search` filters**

```typescript
export function listTasks(filter?: {
  status?: string;
  channel?: string;
  limit?: number;
  tag?: string;
  priority?: string;
  search?: string;
}): TaskRow[] {
  let sql = 'SELECT * FROM tasks WHERE 1=1';
  const params: (string | number)[] = [];
  if (filter?.status) { sql += ' AND status = ?'; params.push(filter.status); }
  if (filter?.channel) { sql += ' AND channel = ?'; params.push(filter.channel); }
  if (filter?.priority) { sql += ' AND priority = ?'; params.push(filter.priority); }
  if (filter?.tag) { sql += " AND tags LIKE '%' || ? || '%'"; params.push(`"${filter.tag}"`); }
  if (filter?.search) { sql += " AND (title LIKE '%' || ? || '%' OR description LIKE '%' || ? || '%')"; params.push(filter.search, filter.search); }
  sql += ' ORDER BY created_at DESC LIMIT ?';
  params.push(filter?.limit ?? 20);
  return getDb().prepare(sql).all(...params) as unknown as TaskRow[];
}
```

**Step 4: Add `deleteTask()` function**

```typescript
export function deleteTask(id: string): boolean {
  const result = getDb().prepare('DELETE FROM tasks WHERE id = ?').run(id);
  return result.changes > 0;
}
```

**Step 5: Add `getUniqueTags()` function**

```typescript
export function getUniqueTags(): string[] {
  const rows = getDb().prepare("SELECT DISTINCT tags FROM tasks WHERE tags != '[]'").all() as unknown as { tags: string }[];
  const tagSet = new Set<string>();
  for (const row of rows) {
    try {
      const parsed = JSON.parse(row.tags) as string[];
      for (const t of parsed) tagSet.add(t);
    } catch { /* skip */ }
  }
  return [...tagSet].sort();
}
```

**Step 6: Update server.ts routes**

Update imports (line 4):
```typescript
import { getRecentMessages, listTasks, createTask, getTask, updateTask, deleteTask, getUniqueTags, getStats, listAgentEvents } from './memory/sqlite.ts';
```

Update `GET /api/tasks` (line 42-49):
```typescript
app.get<{ Querystring: { status?: string; limit?: string; tag?: string; priority?: string; search?: string } }>(
  '/api/tasks',
  async (req) => {
    const { status, limit: limitStr, tag, priority, search } = req.query;
    const limit = parseInt(limitStr ?? '100', 10);
    return listTasks({ status, limit, tag, priority, search });
  },
);
```

Update `POST /api/tasks` (line 67-83) to accept new fields:
```typescript
app.post<{ Body: { title: string; priority?: string; status?: string; description?: string; tags?: string[]; due_at?: string } }>(
  '/api/tasks',
  async (req, reply) => {
    const { title, priority, status, description, tags, due_at } = req.body;
    const id = createTask({
      title,
      createdBy: 'user',
      channel: 'mission_control',
      priority: priority as 'low' | 'medium' | 'high' | undefined,
      description,
      tags,
      dueAt: due_at,
    });
    if (status && status !== 'pending') {
      updateTask(id, { status });
    }
    const task = getTask(id);
    return reply.status(201).send(task);
  },
);
```

Update `PATCH /api/tasks/:id` (line 86-94) to accept new fields:
```typescript
app.patch<{ Params: { id: string }; Body: { status?: string; title?: string; priority?: string; description?: string; tags?: string[]; due_at?: string | null } }>(
  '/api/tasks/:id',
  async (req, reply) => {
    const existing = getTask(req.params.id);
    if (!existing) return reply.status(404).send({ error: 'Task not found' });
    const task = updateTask(req.params.id, req.body);
    return task;
  },
);
```

Add `DELETE /api/tasks/:id`:
```typescript
app.delete<{ Params: { id: string } }>(
  '/api/tasks/:id',
  async (req, reply) => {
    const deleted = deleteTask(req.params.id);
    if (!deleted) return reply.status(404).send({ error: 'Task not found' });
    return { success: true };
  },
);
```

Add `GET /api/tasks/tags`:
```typescript
app.get('/api/tasks/tags', async () => {
  return getUniqueTags();
});
```

Add `GET /api/activity`:
```typescript
app.get<{ Querystring: { limit?: string; type?: string; channel?: string } }>(
  '/api/activity',
  async (req) => {
    const { limit: limitStr, type, channel } = req.query;
    const limit = parseInt(limitStr ?? '100', 10);
    return listAgentEvents({ type, channel, limit });
  },
);
```

**Step 7: Run tests**

Run: `cd "d:/SynologyDrive/IA et agents/makilab" && pnpm test`
Expected: All tests pass.

**Step 8: Commit**

```bash
git add packages/agent/src/memory/sqlite.ts packages/agent/src/server.ts
git commit -m "feat(api): CRUD tasks enrichi, DELETE, tags, filtres, activity endpoint"
```

---

## Task 4: Backend ‚Äî Instrument agent loop with activity logging + enriched SSE events

**Files:**
- Modify: `packages/agent/src/agent-loop-stream.ts`

**Step 1: Import `logAgentEvent`**

Add to imports (line 16-19):
```typescript
import { logAgentEvent } from './memory/sqlite.ts';
```

**Step 2: Enrich `StreamEvent` type**

Update the type (line 66-71):
```typescript
export type StreamEvent =
  | { type: 'text_delta'; content: string }
  | { type: 'tool_start'; name: string; args?: Record<string, unknown> }
  | { type: 'tool_end'; name: string; success: boolean; result?: string }
  | { type: 'done'; fullText: string }
  | { type: 'error'; message: string };
```

**Step 3: Change text events to `text_delta`**

At line 133, change:
```typescript
yield { type: 'text', content: event.delta.text };
```
to:
```typescript
yield { type: 'text_delta', content: event.delta.text };
```

**Step 4: Add args to `tool_start` and result to `tool_end`**

In the tool execution block (lines 148-200), track timing and add args/result:

Before the tool_use loop, add a timestamp tracker. For each tool block:

- At `tool_start` yield: also yield `args: block.input`
- Log `logAgentEvent({ type: 'tool_call', ... })`
- At `tool_end` yield: also yield `result: resultContent.slice(0, 200)`
- Log `logAgentEvent({ type: 'tool_result', ... })`

The updated tool execution section:
```typescript
for (const block of finalMessage.content) {
  if (block.type !== 'tool_use') continue;

  const startTime = Date.now();
  let resultContent: string;
  let success = true;

  // Parse subagent name for logging
  const isSubagent = block.name.includes(SUBAGENT_SEP);
  const [subagentName, ...actionParts] = isSubagent ? block.name.split(SUBAGENT_SEP) : [undefined];
  const actionName = isSubagent ? actionParts.join(SUBAGENT_SEP) : block.name;

  yield { type: 'tool_start', name: block.name, args: block.input as Record<string, unknown> };

  logAgentEvent({
    type: 'tool_call',
    channel,
    subagent: subagentName,
    action: actionName,
    input: block.input,
  });

  if (isSubagent) {
    const subagent = findSubAgent(subagentName ?? '');
    if (!subagent) {
      resultContent = `Erreur : subagent "${subagentName}" introuvable`;
      success = false;
    } else {
      logger.info({ subagent: subagentName, action: actionName }, 'Subagent call');
      const result = await subagent.execute(
        actionName ?? '',
        block.input as Record<string, unknown>,
      );
      resultContent = result.text;
      if (!result.success && result.error) {
        resultContent += `\nErreur: ${result.error}`;
        success = false;
      }
    }
  } else {
    const tool = findTool(block.name);
    if (!tool) {
      resultContent = `Erreur : outil "${block.name}" introuvable`;
      success = false;
    } else {
      try {
        resultContent = await tool.execute(block.input as Record<string, unknown>);
      } catch (err) {
        resultContent = `Erreur lors de l'ex√©cution de ${block.name}: ${err instanceof Error ? err.message : String(err)}`;
        success = false;
      }
    }
  }

  const durationMs = Date.now() - startTime;

  logAgentEvent({
    type: 'tool_result',
    channel,
    subagent: subagentName,
    action: actionName,
    output: resultContent.slice(0, 500),
    success,
    durationMs,
  });

  yield { type: 'tool_end', name: block.name, success, result: resultContent.slice(0, 200) };

  toolResults.push({
    type: 'tool_result',
    tool_use_id: block.id,
    content: resultContent,
  });
}
```

**Step 5: Run tests**

Run: `cd "d:/SynologyDrive/IA et agents/makilab" && pnpm test`
Expected: All tests pass.

**Step 6: Commit**

```bash
git add packages/agent/src/agent-loop-stream.ts
git commit -m "feat(stream): enriched SSE events with args/result + activity logging"
```

---

## Task 5: Frontend API layer ‚Äî Update types and add new API functions

**Files:**
- Modify: `packages/dashboard/app/lib/api.ts`

**Step 1: Update `TaskInfo` type**

```typescript
export interface TaskInfo {
  id: string;
  title: string;
  description: string;
  status: string;
  priority: string;
  tags: string; // JSON array string
  created_by: string;
  channel: string;
  due_at: string | null;
  created_at: string;
  updated_at: string;
}
```

**Step 2: Update `createTaskApi` to accept new fields**

```typescript
export async function createTaskApi(
  title: string,
  priority = 'medium',
  status = 'pending',
  description = '',
  tags: string[] = [],
  due_at?: string,
): Promise<TaskInfo> {
  const res = await fetch(`${API_BASE}/tasks`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ title, priority, status, description, tags, due_at }),
  });
  if (!res.ok) throw new Error(`API error: ${res.status}`);
  return res.json();
}
```

**Step 3: Update `updateTaskApi` to accept new fields**

```typescript
export async function updateTaskApi(
  id: string,
  fields: { status?: string; title?: string; priority?: string; description?: string; tags?: string[]; due_at?: string | null },
): Promise<TaskInfo> {
  const res = await fetch(`${API_BASE}/tasks/${id}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(fields),
  });
  if (!res.ok) throw new Error(`API error: ${res.status}`);
  return res.json();
}
```

**Step 4: Add `deleteTaskApi`**

```typescript
export async function deleteTaskApi(id: string): Promise<void> {
  const res = await fetch(`${API_BASE}/tasks/${id}`, { method: 'DELETE' });
  if (!res.ok) throw new Error(`API error: ${res.status}`);
}
```

**Step 5: Add `fetchTags`**

```typescript
export async function fetchTags(): Promise<string[]> {
  const res = await fetch(`${API_BASE}/tasks/tags`);
  if (!res.ok) throw new Error(`API error: ${res.status}`);
  return res.json();
}
```

**Step 6: Add `fetchActivity`**

```typescript
export interface AgentEvent {
  id: number;
  type: string;
  channel: string;
  subagent: string | null;
  action: string | null;
  input: string | null;
  output: string | null;
  success: number | null;
  duration_ms: number | null;
  created_at: string;
}

export async function fetchActivity(limit = 100, type?: string): Promise<AgentEvent[]> {
  const params = new URLSearchParams({ limit: String(limit) });
  if (type) params.set('type', type);
  const res = await fetch(`${API_BASE}/activity?${params}`);
  if (!res.ok) throw new Error(`API error: ${res.status}`);
  return res.json();
}
```

**Step 7: Commit**

```bash
git add packages/dashboard/app/lib/api.ts
git commit -m "feat(dashboard): update API layer with CRUD, tags, activity types"
```

---

## Task 6: Frontend ‚Äî Enriched TaskCard + FilterBar

**Files:**
- Modify: `packages/dashboard/app/components/task-card.tsx`
- Create: `packages/dashboard/app/components/filter-bar.tsx`
- Modify: `packages/dashboard/app/globals.css` (add tag + filter CSS)

**Step 1: Create tag color utility**

Add to `task-card.tsx`:
```typescript
const TAG_COLORS = [
  '#5423e7', '#22c55e', '#f59e0b', '#ef4444',
  '#06b6d4', '#8b5cf6', '#ec4899', '#14b8a6',
];

function tagColor(tag: string): string {
  let hash = 0;
  for (let i = 0; i < tag.length; i++) hash = ((hash << 5) - hash + tag.charCodeAt(i)) | 0;
  return TAG_COLORS[Math.abs(hash) % TAG_COLORS.length];
}
```

**Step 2: Update TaskCard to show description, tags, due_at**

```typescript
export function TaskCard({ task, onClick }: { task: TaskInfo; onClick?: () => void }) {
  const { attributes, listeners, setNodeRef, transform, transition, isDragging } = useSortable({ id: task.id });
  const style = { transform: CSS.Transform.toString(transform), transition };

  const date = new Date(task.created_at).toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' });
  const tags: string[] = (() => { try { return JSON.parse(task.tags); } catch { return []; } })();
  const hasDue = !!task.due_at;

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={`card kanban-card${isDragging ? ' dragging' : ''}`}
      {...attributes}
      {...listeners}
      onClick={onClick}
    >
      <div className="kanban-card-header">
        <span className="kanban-card-title">{task.title}</span>
        <span className={PRIORITY_CLASS[task.priority] ?? 'badge badge-muted'}>
          {PRIORITY_LABEL[task.priority] ?? task.priority}
        </span>
      </div>
      {task.description && (
        <div className="kanban-card-desc">{task.description}</div>
      )}
      {tags.length > 0 && (
        <div className="kanban-card-tags">
          {tags.map(t => (
            <span key={t} className="tag-badge" style={{ background: tagColor(t) }}>{t}</span>
          ))}
        </div>
      )}
      <div className="kanban-card-meta">
        <span>{task.created_by || 'system'}</span>
        <span>{hasDue ? `üìÖ ${new Date(task.due_at!).toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' })}` : date}</span>
      </div>
    </div>
  );
}
```

**Step 3: Create FilterBar component**

Create `packages/dashboard/app/components/filter-bar.tsx`:

```typescript
'use client';
import { useState, useEffect } from 'react';
import { fetchTags } from '../lib/api';

interface Props {
  onFilterChange: (filters: { search: string; tag: string; priority: string }) => void;
}

export function FilterBar({ onFilterChange }: Props) {
  const [search, setSearch] = useState('');
  const [tag, setTag] = useState('');
  const [priority, setPriority] = useState('');
  const [availableTags, setAvailableTags] = useState<string[]>([]);

  useEffect(() => {
    fetchTags().then(setAvailableTags).catch(() => {});
  }, []);

  useEffect(() => {
    onFilterChange({ search, tag, priority });
  }, [search, tag, priority]);

  return (
    <div className="filter-bar">
      <input
        type="text"
        className="textarea filter-search"
        placeholder="Rechercher..."
        value={search}
        onChange={e => setSearch(e.target.value)}
      />
      <select className="textarea filter-select" value={tag} onChange={e => setTag(e.target.value)}>
        <option value="">Tous les tags</option>
        {availableTags.map(t => <option key={t} value={t}>{t}</option>)}
      </select>
      <select className="textarea filter-select" value={priority} onChange={e => setPriority(e.target.value)}>
        <option value="">Toutes priorites</option>
        <option value="high">Haute</option>
        <option value="medium">Moyenne</option>
        <option value="low">Basse</option>
      </select>
      {(search || tag || priority) && (
        <button className="btn btn-ghost" onClick={() => { setSearch(''); setTag(''); setPriority(''); }}>
          Effacer
        </button>
      )}
    </div>
  );
}
```

**Step 4: Add CSS for tags and filter bar**

Append to `globals.css`:
```css
/* ‚îÄ‚îÄ‚îÄ Tags ‚îÄ‚îÄ‚îÄ */
.kanban-card-tags { display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 6px; }
.tag-badge { display: inline-flex; padding: 1px 8px; border-radius: 9999px; font-size: 0.6875rem; font-weight: 500; color: white; }
.kanban-card-desc { font-size: 0.75rem; color: var(--muted-foreground); line-height: 1.4; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-bottom: 6px; }

/* ‚îÄ‚îÄ‚îÄ Filter bar ‚îÄ‚îÄ‚îÄ */
.filter-bar { display: flex; gap: 8px; align-items: center; }
.filter-search { max-width: 240px; height: auto; padding: 8px 12px; }
.filter-select { width: auto; height: auto; padding: 8px 12px; }
```

**Step 5: Commit**

```bash
git add packages/dashboard/app/components/task-card.tsx packages/dashboard/app/components/filter-bar.tsx packages/dashboard/app/globals.css
git commit -m "feat(dashboard): enriched task cards with tags, description + filter bar"
```

---

## Task 7: Frontend ‚Äî TaskDetailPanel (slide-in edit panel)

**Files:**
- Create: `packages/dashboard/app/components/task-detail-panel.tsx`
- Modify: `packages/dashboard/app/globals.css` (add panel CSS)

**Step 1: Create TaskDetailPanel**

Create `packages/dashboard/app/components/task-detail-panel.tsx`:

```typescript
'use client';
import { useState, useEffect } from 'react';
import { updateTaskApi, deleteTaskApi, fetchTags, type TaskInfo } from '../lib/api';

interface Props {
  task: TaskInfo | null;
  onClose: () => void;
  onUpdated: (task: TaskInfo) => void;
  onDeleted: (id: string) => void;
}

export function TaskDetailPanel({ task, onClose, onUpdated, onDeleted }: Props) {
  const [title, setTitle] = useState('');
  const [description, setDescription] = useState('');
  const [priority, setPriority] = useState('medium');
  const [tags, setTags] = useState<string[]>([]);
  const [tagInput, setTagInput] = useState('');
  const [dueAt, setDueAt] = useState('');
  const [availableTags, setAvailableTags] = useState<string[]>([]);
  const [confirmDelete, setConfirmDelete] = useState(false);
  const [saving, setSaving] = useState(false);

  useEffect(() => {
    if (!task) return;
    setTitle(task.title);
    setDescription(task.description || '');
    setPriority(task.priority);
    setDueAt(task.due_at ?? '');
    setConfirmDelete(false);
    try { setTags(JSON.parse(task.tags)); } catch { setTags([]); }
  }, [task]);

  useEffect(() => {
    fetchTags().then(setAvailableTags).catch(() => {});
  }, []);

  if (!task) return null;

  async function save(fields: Partial<Parameters<typeof updateTaskApi>[1]>) {
    if (!task) return;
    setSaving(true);
    try {
      const updated = await updateTaskApi(task.id, fields);
      onUpdated(updated);
    } catch (err) { console.error(err); }
    finally { setSaving(false); }
  }

  function addTag(t: string) {
    const trimmed = t.trim().toLowerCase();
    if (!trimmed || tags.includes(trimmed)) return;
    const newTags = [...tags, trimmed];
    setTags(newTags);
    setTagInput('');
    save({ tags: newTags });
  }

  function removeTag(t: string) {
    const newTags = tags.filter(x => x !== t);
    setTags(newTags);
    save({ tags: newTags });
  }

  async function handleDelete() {
    if (!task) return;
    try {
      await deleteTaskApi(task.id);
      onDeleted(task.id);
      onClose();
    } catch (err) { console.error(err); }
  }

  const suggestions = availableTags.filter(t => !tags.includes(t) && t.includes(tagInput.toLowerCase()));

  return (
    <div className="detail-panel-overlay" onClick={onClose}>
      <div className="detail-panel" onClick={e => e.stopPropagation()}>
        <div className="detail-panel-header">
          <h3>Details</h3>
          <button className="btn btn-ghost" onClick={onClose}>‚úï</button>
        </div>

        <div className="detail-panel-body">
          <label className="detail-label">Titre</label>
          <input
            className="textarea"
            style={{ height: 'auto', padding: '8px 12px' }}
            value={title}
            onChange={e => setTitle(e.target.value)}
            onBlur={() => title !== task.title && save({ title })}
          />

          <label className="detail-label">Description</label>
          <textarea
            className="textarea"
            rows={4}
            value={description}
            onChange={e => setDescription(e.target.value)}
            onBlur={() => description !== (task.description || '') && save({ description })}
            placeholder="Ajouter une description..."
          />

          <label className="detail-label">Priorite</label>
          <select
            className="textarea"
            style={{ height: 'auto', padding: '8px 12px' }}
            value={priority}
            onChange={e => { setPriority(e.target.value); save({ priority: e.target.value }); }}
          >
            <option value="low">Basse</option>
            <option value="medium">Moyenne</option>
            <option value="high">Haute</option>
          </select>

          <label className="detail-label">Tags</label>
          <div className="detail-tags">
            {tags.map(t => (
              <span key={t} className="tag-badge tag-removable" style={{ background: tagColor(t) }} onClick={() => removeTag(t)}>
                {t} ‚úï
              </span>
            ))}
          </div>
          <input
            className="textarea"
            style={{ height: 'auto', padding: '8px 12px' }}
            value={tagInput}
            onChange={e => setTagInput(e.target.value)}
            onKeyDown={e => { if (e.key === 'Enter') { e.preventDefault(); addTag(tagInput); } }}
            placeholder="Ajouter un tag..."
          />
          {tagInput && suggestions.length > 0 && (
            <div className="tag-suggestions">
              {suggestions.slice(0, 5).map(s => (
                <button key={s} className="btn btn-ghost tag-suggestion" onClick={() => addTag(s)}>{s}</button>
              ))}
            </div>
          )}

          <label className="detail-label">Echeance</label>
          <input
            type="date"
            className="textarea"
            style={{ height: 'auto', padding: '8px 12px' }}
            value={dueAt ? dueAt.slice(0, 10) : ''}
            onChange={e => { setDueAt(e.target.value); save({ due_at: e.target.value || null }); }}
          />
        </div>

        <div className="detail-panel-footer">
          {!confirmDelete ? (
            <button className="btn btn-ghost text-destructive" onClick={() => setConfirmDelete(true)}>
              Supprimer
            </button>
          ) : (
            <div style={{ display: 'flex', gap: 8 }}>
              <button className="btn btn-ghost" onClick={() => setConfirmDelete(false)}>Annuler</button>
              <button className="btn" style={{ background: 'var(--destructive)', color: 'white' }} onClick={handleDelete}>
                Confirmer
              </button>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

// Tag color utility (same as task-card)
const TAG_COLORS = ['#5423e7', '#22c55e', '#f59e0b', '#ef4444', '#06b6d4', '#8b5cf6', '#ec4899', '#14b8a6'];
function tagColor(tag: string): string {
  let hash = 0;
  for (let i = 0; i < tag.length; i++) hash = ((hash << 5) - hash + tag.charCodeAt(i)) | 0;
  return TAG_COLORS[Math.abs(hash) % TAG_COLORS.length];
}
```

**Step 2: Add CSS for detail panel**

Append to `globals.css`:
```css
/* ‚îÄ‚îÄ‚îÄ Detail panel (slide-in) ‚îÄ‚îÄ‚îÄ */
.detail-panel-overlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.3); z-index: 100; display: flex; justify-content: flex-end; }
.detail-panel { width: 400px; max-width: 90vw; height: 100vh; background: var(--card); border-left: 1px solid var(--border); display: flex; flex-direction: column; animation: slideIn 0.2s ease-out; }
@keyframes slideIn { from { transform: translateX(100%); } to { transform: translateX(0); } }
.detail-panel-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); }
.detail-panel-header h3 { margin: 0; font-size: 1rem; }
.detail-panel-body { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 12px; }
.detail-label { font-size: 0.75rem; font-weight: 600; text-transform: uppercase; color: var(--muted-foreground); letter-spacing: 0.05em; }
.detail-tags { display: flex; flex-wrap: wrap; gap: 6px; }
.tag-removable { cursor: pointer; }
.tag-removable:hover { filter: brightness(0.85); }
.tag-suggestions { display: flex; flex-wrap: wrap; gap: 4px; }
.tag-suggestion { padding: 4px 8px; font-size: 0.75rem; }
.detail-panel-footer { padding: 16px 20px; border-top: 1px solid var(--border); }
```

**Step 3: Commit**

```bash
git add packages/dashboard/app/components/task-detail-panel.tsx packages/dashboard/app/globals.css
git commit -m "feat(dashboard): task detail panel with edit, tags, delete"
```

---

## Task 8: Frontend ‚Äî Wire everything into tasks page + kanban

**Files:**
- Modify: `packages/dashboard/app/tasks/page.tsx`
- Modify: `packages/dashboard/app/components/kanban-board.tsx`
- Modify: `packages/dashboard/app/components/new-task-modal.tsx`

**Step 1: Update tasks page to integrate FilterBar + TaskDetailPanel**

Full rewrite of `packages/dashboard/app/tasks/page.tsx`:

```typescript
'use client';
import { useState, useEffect, useCallback } from 'react';
import { fetchTasks, type TaskInfo } from '../lib/api';
import { KanbanBoard } from '../components/kanban-board';
import { NewTaskModal } from '../components/new-task-modal';
import { FilterBar } from '../components/filter-bar';
import { TaskDetailPanel } from '../components/task-detail-panel';

export default function TasksPage() {
  const [tasks, setTasks] = useState<TaskInfo[]>([]);
  const [filteredTasks, setFilteredTasks] = useState<TaskInfo[]>([]);
  const [modalOpen, setModalOpen] = useState(false);
  const [selectedTask, setSelectedTask] = useState<TaskInfo | null>(null);
  const [filters, setFilters] = useState({ search: '', tag: '', priority: '' });

  useEffect(() => {
    fetchTasks(200).then(setTasks).catch(console.error);
  }, []);

  useEffect(() => {
    let result = tasks;
    if (filters.priority) result = result.filter(t => t.priority === filters.priority);
    if (filters.tag) result = result.filter(t => {
      try { return (JSON.parse(t.tags) as string[]).includes(filters.tag); } catch { return false; }
    });
    if (filters.search) {
      const q = filters.search.toLowerCase();
      result = result.filter(t => t.title.toLowerCase().includes(q) || (t.description || '').toLowerCase().includes(q));
    }
    setFilteredTasks(result);
  }, [tasks, filters]);

  function handleCreated(task: TaskInfo) {
    setTasks(prev => [task, ...prev]);
  }

  function handleUpdated(updated: TaskInfo) {
    setTasks(prev => prev.map(t => t.id === updated.id ? updated : t));
    setSelectedTask(updated);
  }

  function handleDeleted(id: string) {
    setTasks(prev => prev.filter(t => t.id !== id));
  }

  return (
    <div className="tasks-container">
      <div className="tasks-header">
        <h1 style={{ fontSize: '1.5rem', fontWeight: 600, margin: 0 }}>Taches</h1>
        <button className="btn btn-primary" onClick={() => setModalOpen(true)}>
          + Nouvelle tache
        </button>
      </div>
      <FilterBar onFilterChange={setFilters} />
      <KanbanBoard
        tasks={filteredTasks}
        onTasksChange={updated => setTasks(prev => {
          const ids = new Set(updated.map(t => t.id));
          return [...prev.filter(t => !ids.has(t.id)), ...updated];
        })}
        onRequestAdd={() => setModalOpen(true)}
        onTaskClick={setSelectedTask}
      />
      <NewTaskModal open={modalOpen} onClose={() => setModalOpen(false)} onCreated={handleCreated} />
      <TaskDetailPanel
        task={selectedTask}
        onClose={() => setSelectedTask(null)}
        onUpdated={handleUpdated}
        onDeleted={handleDeleted}
      />
    </div>
  );
}
```

**Step 2: Update KanbanBoard to accept `onTaskClick`**

In `kanban-board.tsx`, add `onTaskClick` to Props and pass to Column/TaskCard:

- Props: add `onTaskClick?: (task: TaskInfo) => void`
- Column: add `onTaskClick` prop, pass to TaskCard
- TaskCard rendering: pass `onClick={() => onTaskClick?.(task)}`

**Step 3: Update NewTaskModal to include description, tags, due_at**

Add description textarea, tag input, and date input to the modal form. Update the submit handler to pass new fields to `createTaskApi`.

**Step 4: Build dashboard to verify**

Run: `cd "d:/SynologyDrive/IA et agents/makilab" && pnpm --filter @makilab/dashboard build`
Expected: Build succeeds.

**Step 5: Commit**

```bash
git add packages/dashboard/app/tasks/page.tsx packages/dashboard/app/components/kanban-board.tsx packages/dashboard/app/components/new-task-modal.tsx
git commit -m "feat(dashboard): wired CRUD kanban with filters, detail panel, enriched modal"
```

---

## Task 9: Frontend ‚Äî Activity page

**Files:**
- Create: `packages/dashboard/app/activity/page.tsx`
- Modify: `packages/dashboard/app/components/sidebar.tsx` (add Activity link)
- Modify: `packages/dashboard/app/globals.css` (add activity CSS)

**Step 1: Create Activity page**

Create `packages/dashboard/app/activity/page.tsx`:

```typescript
'use client';
import { useState, useEffect } from 'react';
import { fetchActivity, type AgentEvent } from '../lib/api';

const TYPE_ICONS: Record<string, string> = {
  tool_call: 'üîß',
  tool_result: 'üì§',
  message: 'üí¨',
  error: '‚ùå',
};

function relativeTime(dateStr: string): string {
  const diff = Date.now() - new Date(dateStr).getTime();
  const mins = Math.floor(diff / 60000);
  if (mins < 1) return 'a l\'instant';
  if (mins < 60) return `il y a ${mins} min`;
  const hours = Math.floor(mins / 60);
  if (hours < 24) return `il y a ${hours}h`;
  return `il y a ${Math.floor(hours / 24)}j`;
}

export default function ActivityPage() {
  const [events, setEvents] = useState<AgentEvent[]>([]);
  const [typeFilter, setTypeFilter] = useState('');
  const [expanded, setExpanded] = useState<Set<number>>(new Set());

  useEffect(() => {
    fetchActivity(200, typeFilter || undefined).then(setEvents).catch(console.error);
  }, [typeFilter]);

  function toggleExpand(id: number) {
    setExpanded(prev => {
      const next = new Set(prev);
      next.has(id) ? next.delete(id) : next.add(id);
      return next;
    });
  }

  return (
    <div className="activity-container">
      <div className="activity-header">
        <h1 style={{ fontSize: '1.5rem', fontWeight: 600, margin: 0 }}>Activite</h1>
        <select className="textarea filter-select" value={typeFilter} onChange={e => setTypeFilter(e.target.value)}>
          <option value="">Tous les types</option>
          <option value="tool_call">Tool calls</option>
          <option value="tool_result">Resultats</option>
          <option value="error">Erreurs</option>
        </select>
      </div>
      <div className="activity-timeline">
        {events.length === 0 && <p className="text-muted">Aucune activite enregistree.</p>}
        {events.map(ev => (
          <div key={ev.id} className="activity-event" onClick={() => toggleExpand(ev.id)}>
            <div className="activity-event-header">
              <span className="activity-icon">{TYPE_ICONS[ev.type] ?? 'üìå'}</span>
              <span className="activity-event-name">
                {ev.subagent ? `${ev.subagent} ‚Üí ${ev.action}` : ev.type}
              </span>
              {ev.success !== null && (
                <span className={`badge ${ev.success ? 'badge-success' : 'badge-destructive'}`}>
                  {ev.success ? 'OK' : 'Echec'}
                </span>
              )}
              {ev.duration_ms !== null && (
                <span className="text-muted">{ev.duration_ms}ms</span>
              )}
              <span className="text-muted" style={{ marginLeft: 'auto' }}>{relativeTime(ev.created_at)}</span>
            </div>
            {expanded.has(ev.id) && (
              <div className="activity-event-detail">
                {ev.input && <div><strong>Input:</strong> <pre>{ev.input}</pre></div>}
                {ev.output && <div><strong>Output:</strong> <pre>{ev.output}</pre></div>}
              </div>
            )}
          </div>
        ))}
      </div>
    </div>
  );
}
```

**Step 2: Add Activity to sidebar**

In `sidebar.tsx`, add to the OVERVIEW section:
```typescript
{ href: '/activity', label: 'Activite', icon: 'üìä' },
```

**Step 3: Add CSS**

Append to `globals.css`:
```css
/* ‚îÄ‚îÄ‚îÄ Activity ‚îÄ‚îÄ‚îÄ */
.activity-container { display: flex; flex-direction: column; gap: 16px; }
.activity-header { display: flex; align-items: center; justify-content: space-between; }
.activity-timeline { display: flex; flex-direction: column; gap: 2px; }
.activity-event { padding: 12px 16px; border-radius: var(--radius); cursor: pointer; transition: background 0.15s; border: 1px solid var(--border); }
.activity-event:hover { background: var(--muted); }
.activity-event-header { display: flex; align-items: center; gap: 10px; font-size: 0.875rem; }
.activity-icon { font-size: 1rem; }
.activity-event-name { font-weight: 500; }
.activity-event-detail { margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border); font-size: 0.8125rem; }
.activity-event-detail pre { background: var(--muted); padding: 8px; border-radius: var(--radius); font-family: var(--font-mono); font-size: 0.75rem; overflow-x: auto; white-space: pre-wrap; word-break: break-all; margin: 4px 0; }
```

**Step 4: Build dashboard to verify**

Run: `cd "d:/SynologyDrive/IA et agents/makilab" && pnpm --filter @makilab/dashboard build`
Expected: Build succeeds with 6 routes.

**Step 5: Commit**

```bash
git add packages/dashboard/app/activity/page.tsx packages/dashboard/app/components/sidebar.tsx packages/dashboard/app/globals.css
git commit -m "feat(dashboard): activity page with timeline and filters"
```

---

## Task 10: Frontend ‚Äî Chat UX with token streaming + tool call blocks

**Files:**
- Modify: `packages/dashboard/app/chat/page.tsx`
- Modify: `packages/dashboard/app/globals.css` (add tool block CSS)

**Step 1: Update chat page to handle `text_delta` and enriched tool events**

Replace the streaming event handler in `chat/page.tsx` to:
- Handle `text_delta` instead of `text`
- Show tool call blocks (d√©pliables) with args and results
- Track active tool calls in state

Key changes:
- Add `toolCalls` state: `useState<Array<{ name: string; args?: unknown; result?: string; success?: boolean; loading: boolean }>>([])`
- On `text_delta`: same as old `text` handler
- On `tool_start`: push new entry to toolCalls with `loading: true` and `args`
- On `tool_end`: update the matching toolCall with `result`, `success`, `loading: false`
- Render tool call blocks inline between messages

**Step 2: Create ToolCallBlock component inline**

```typescript
function ToolCallBlock({ call }: { call: { name: string; args?: unknown; result?: string; success?: boolean; loading: boolean } }) {
  const [expanded, setExpanded] = useState(false);
  const displayName = call.name.replace('__', ' ‚Üí ');

  return (
    <div className={`tool-call-block ${call.loading ? 'loading' : call.success ? 'success' : 'error'}`}>
      <div className="tool-call-header" onClick={() => setExpanded(!expanded)}>
        {call.loading && <span className="chat-tool-spinner" />}
        {!call.loading && <span>{call.success ? '‚úì' : '‚úï'}</span>}
        <span className="tool-call-name">{displayName}</span>
        <span className="tool-call-expand">{expanded ? '‚ñº' : '‚ñ∂'}</span>
      </div>
      {expanded && (
        <div className="tool-call-detail">
          {call.args && <div><strong>Args:</strong><pre>{JSON.stringify(call.args, null, 2)}</pre></div>}
          {call.result && <div><strong>Resultat:</strong><pre>{call.result}</pre></div>}
        </div>
      )}
    </div>
  );
}
```

**Step 3: Add CSS for tool call blocks**

Append to `globals.css`:
```css
/* ‚îÄ‚îÄ‚îÄ Tool call blocks ‚îÄ‚îÄ‚îÄ */
.tool-call-block { border: 1px solid var(--border); border-radius: var(--radius); margin: 4px 0; font-size: 0.8125rem; max-width: 75%; }
.tool-call-block.loading { border-color: var(--primary); }
.tool-call-block.success { border-color: #22c55e; }
.tool-call-block.error { border-color: var(--destructive); }
.tool-call-header { display: flex; align-items: center; gap: 8px; padding: 8px 12px; cursor: pointer; }
.tool-call-header:hover { background: var(--muted); }
.tool-call-name { font-weight: 500; flex: 1; }
.tool-call-expand { font-size: 0.625rem; color: var(--muted-foreground); }
.tool-call-detail { padding: 8px 12px; border-top: 1px solid var(--border); }
.tool-call-detail pre { background: var(--muted); padding: 8px; border-radius: var(--radius); font-family: var(--font-mono); font-size: 0.75rem; overflow-x: auto; white-space: pre-wrap; word-break: break-all; margin: 4px 0; }
```

**Step 4: Build dashboard to verify**

Run: `cd "d:/SynologyDrive/IA et agents/makilab" && pnpm --filter @makilab/dashboard build`
Expected: Build succeeds.

**Step 5: Commit**

```bash
git add packages/dashboard/app/chat/page.tsx packages/dashboard/app/globals.css
git commit -m "feat(dashboard): chat with token streaming + tool call detail blocks"
```

---

## Task 11: Final ‚Äî Run all tests + update PROGRESS.md

**Files:**
- Modify: `PROGRESS.md`

**Step 1: Run tests**

Run: `cd "d:/SynologyDrive/IA et agents/makilab" && pnpm test`
Expected: All tests pass.

**Step 2: Build dashboard**

Run: `cd "d:/SynologyDrive/IA et agents/makilab" && pnpm --filter @makilab/dashboard build`
Expected: Build succeeds with 6 routes.

**Step 3: Update PROGRESS.md with E10.5 completion**

**Step 4: Commit**

```bash
git add PROGRESS.md
git commit -m "chore: PROGRESS.md ‚Äî E10.5 Kanban CRUD + Activity + Chat UX termin√©"
```
