# E14.5 — Smart Model Catalog + Notifications

**Date :** 2026-03-01
**Dépend de :** E14 ✅ (LLM Router + Cost Tracking)
**Scope :** Catalogue OpenRouter dynamique, smart routing, moteur de notifications, pages dashboard enrichies

---

## Problème

Le LLM Router E14 a 5 modèles hardcodés dans `pricing.ts` et 6 routes statiques dans `router.ts`. OpenRouter propose 342+ modèles dont 29 gratuits. Les prix changent régulièrement, de nouveaux modèles sortent, et l'utilisateur n'a aucune visibilité sur les alternatives possibles ni les économies potentielles.

De plus, le système n'a aucun moyen de notifier l'utilisateur proactivement (optimisations disponibles, échecs de tâches, alertes système). Le seul canal est le chat, qui est pull-only.

## Solution

6 blocs complémentaires :
1. Catalogue dynamique OpenRouter (fetch + cache SQLite)
2. Routing configurable par task type (remplace les constantes)
3. Moteur de notifications multi-canal
4. Page `/costs` enrichie (monitoring + économies potentielles)
5. Page `/models` (catalogue + routing + suggestions)
6. Briefing hebdo coûts (tâche récurrente seed)

---

## Bloc 1 — Catalogue dynamique

### Source

`GET https://openrouter.ai/api/v1/models` — endpoint public, gratuit, pas de rate limit, pas d'API key requise.

### Modèle de données — table `llm_models`

```sql
CREATE TABLE llm_models (
  id TEXT PRIMARY KEY,           -- 'google/gemini-2.5-flash'
  name TEXT NOT NULL,            -- 'Google: Gemini 2.5 Flash'
  provider_slug TEXT NOT NULL,   -- 'google'
  context_length INTEGER NOT NULL,
  price_input_per_m REAL NOT NULL,   -- USD per million tokens input
  price_output_per_m REAL NOT NULL,  -- USD per million tokens output
  supports_tools INTEGER NOT NULL DEFAULT 0,
  supports_reasoning INTEGER NOT NULL DEFAULT 0,
  modality TEXT NOT NULL DEFAULT 'text->text',
  updated_at TEXT NOT NULL       -- ISO 8601
);
```

### Module `packages/agent/src/llm/catalog.ts`

```typescript
// Fetch + parse + upsert all models into SQLite
export async function refreshCatalog(): Promise<number>;

// Read from SQLite cache (fast)
export function getCatalog(filters?: CatalogFilter): ModelInfo[];
export function getModel(id: string): ModelInfo | null;

// Called at boot + daily CRON
export async function initCatalog(): Promise<void>;
```

### Refresh strategy

- **Au boot** : `initCatalog()` fetch si cache vide ou > 24h
- **CRON daily** : 3h du matin, `refreshCatalog()`
- **Manuel** : `POST /api/models/refresh` depuis le dashboard
- **Fallback** : si fetch échoue, le cache SQLite reste valide

### Modèles Anthropic

Les modèles Anthropic (claude-*) ne sont pas sur OpenRouter avec les mêmes IDs. On les ajoute manuellement dans le catalogue au boot avec les prix connus. Ils sont marqués `provider_slug = 'anthropic'` et ne sont pas écrasés par le refresh OpenRouter.

---

## Bloc 2 — Routing configurable

### Modèle de données — table `llm_route_config`

```sql
CREATE TABLE llm_route_config (
  task_type TEXT PRIMARY KEY,    -- 'conversation', 'compaction', etc.
  model_id TEXT NOT NULL,        -- FK vers llm_models.id
  updated_at TEXT NOT NULL
);
```

Pré-peuplé au boot avec les routes actuelles :

| task_type | model_id |
|---|---|
| conversation | claude-sonnet-4-6 |
| compaction | claude-haiku-4-5-20251001 |
| fact_extraction | claude-haiku-4-5-20251001 |
| classification | google/gemini-2.0-flash-001 |
| cron_task | claude-sonnet-4-6 |
| orchestration | claude-haiku-4-5-20251001 |

### Refactoring `router.ts`

`resolveModel()` lit la route depuis `llm_route_config` au lieu de `DEFAULT_ROUTES`. Fallback inchangé : si openrouter key absente et route = openrouter → fallback Haiku Anthropic.

### Refactoring `pricing.ts`

- `calculateCost()` lit `price_input_per_m` / `price_output_per_m` depuis `llm_models` SQLite
- `listAvailableModels()` retourne les modèles du catalogue filtrés (text modality, tools support)
- Le dict PRICING hardcodé est supprimé

### Scoring automatique

Pour chaque task type, un scorer :

1. **Filtre** : supports_tools si nécessaire, context_length >= 32K, modality inclut text, exclut prix = 0 (gratuits instables)
2. **Score** = `1 / (price_input + price_output) * capability_bonus`
   - `capability_bonus` : +50% si supports_reasoning (pour complex tasks), +20% si context >= 200K
3. **Retourne top 3** triés par score

### Classification LLM à la création de tâche récurrente

Quand `tasks__create` est appelé avec un `cron_expression`, un micro-appel LLM (Haiku) classifie le `cron_prompt` :

```json
{ "complexity": "simple|moderate|complex", "sensitive": false, "needs_tools": true }
```

Mapping :
- `simple` + pas tools → modèle le moins cher (GPT-5-nano, Gemini Flash Lite)
- `simple` + tools → modèle cheap avec tools (Gemini Flash, GPT-4.1-nano)
- `moderate` → mid-range (Haiku, GPT-4.1-mini)
- `complex` → haut de gamme (Sonnet, GPT-4.1, Gemini Pro)
- `sensitive: true` → force Anthropic (règle sécurité existante)

Le modèle est assigné automatiquement sur la tâche, overridable par l'utilisateur.

---

## Bloc 3 — Moteur de notifications

### Modèle de données

```sql
CREATE TABLE notifications (
  id TEXT PRIMARY KEY,
  type TEXT NOT NULL,              -- 'cost_optimization', 'task_failure', 'system_alert', 'catalog_update'
  severity TEXT NOT NULL DEFAULT 'info',  -- 'info', 'warning', 'critical'
  title TEXT NOT NULL,
  body TEXT NOT NULL,
  link TEXT,                       -- '/models', '/tasks', '/costs'
  read INTEGER NOT NULL DEFAULT 0,
  created_at TEXT NOT NULL
);

CREATE TABLE notification_settings (
  channel TEXT PRIMARY KEY,        -- 'mission_control', 'whatsapp', 'email'
  enabled INTEGER NOT NULL DEFAULT 1,
  types_filter TEXT,               -- JSON array: ["cost_optimization", "task_failure"] ou null = tous
  quiet_hours_start TEXT,          -- '22:00' ou null
  quiet_hours_end TEXT,            -- '08:00' ou null
  updated_at TEXT NOT NULL
);
```

Settings pré-peuplés :

| channel | enabled | types_filter | quiet_hours |
|---|---|---|---|
| mission_control | 1 | null (tous) | null |
| whatsapp | 1 | ["task_failure", "system_alert"] | 22:00-08:00 |
| email | 0 | null | null |

### Module `packages/agent/src/notifications/engine.ts`

```typescript
export interface NotificationPayload {
  type: string;
  severity: 'info' | 'warning' | 'critical';
  title: string;
  body: string;
  link?: string;
}

// Create notification + dispatch to active channels
export async function notify(payload: NotificationPayload): Promise<void>;

// Query
export function getNotifications(opts?: { unreadOnly?: boolean; limit?: number }): Notification[];
export function getUnreadCount(): number;
export function markRead(id: string): void;
export function markAllRead(): void;

// Settings
export function getNotificationSettings(): NotificationSetting[];
export function updateNotificationSettings(channel: string, settings: Partial<NotificationSetting>): void;
```

### Dispatch par canal

- **mission_control** : insert dans `notifications` table (le dashboard poll ou SSE)
- **whatsapp** : envoie via `WhatsAppSessionManager.sendMessage()` (si gateway connecté)
- **email** : via subagent Gmail `gmail__create_draft` (envoi différé, l'utilisateur valide)

### API endpoints

- `GET /api/notifications` — liste (query: `?unread=true&limit=20`)
- `GET /api/notifications/count` — `{ unread: 5 }`
- `PATCH /api/notifications/:id` — `{ read: true }`
- `POST /api/notifications/read-all` — mark all read
- `GET /api/notification-settings` — liste des canaux + config
- `PATCH /api/notification-settings/:channel` — update config

### Dashboard UI

- **Header** : icône cloche à côté du nom utilisateur, badge rouge avec compteur unread
- **Dropdown** : clic sur cloche → liste des 10 dernières notifs, bouton "tout marquer lu"
- **Clic sur notif** → navigation vers `link` (/models, /costs, /tasks)
- **Page `/settings/notifications`** : toggle par canal, sélection des types, quiet hours

### Premiers émetteurs

1. **cost_optimization** (info) — scorer détecte >30% d'économie possible sur une route active
2. **task_failure** (warning) — tâche récurrente échoue 3x consécutives
3. **catalog_update** (info) — nouveau modèle détecté dans le top 3 d'un task type

---

## Bloc 4 — Page `/costs` enrichie

Refonte de la page existante :

### Section 1 : Stat cards (haut de page)
- Dépense aujourd'hui | Cette semaine | Ce mois
- Variation vs période précédente (↑12% ou ↓8%)

### Section 2 : Graphe historique
- Barres par jour, 30 derniers jours
- Couleurs par modèle (stacked bars)

### Section 3 : Breakdowns
- Par modèle (pie chart) — "Sonnet 78%, Haiku 15%, Flash 7%"
- Par task type (pie chart) — "conversation 60%, cron 25%, extraction 15%"
- Par canal (pie chart) — "WhatsApp 50%, Mission Control 35%, CRON 15%"

### Section 4 : Économies potentielles
- Pour chaque task type : modèle actuel vs meilleur recommandé
- Delta en % et en USD estimé (basé sur usage du mois en cours)
- Lien "Changer" → navigue vers `/models` routing section

### Section 5 : Derniers appels LLM
- Table des appels récents (existante, enrichie avec nom modèle lisible)

---

## Bloc 5 — Page `/models`

Nouvelle page dans la sidebar (section MANAGE).

### Section 1 : Optimisations suggérées (haut de page)
- Cards d'alerte : "conversation : Sonnet ($3/$15) → Gemini Pro ($1.25/$10) = -58%"
- Bouton "Appliquer" pour changer la route en un clic

### Section 2 : Routing par task type
- 6 cards, une par task type
- Chaque card : modèle actif (dropdown sélecteur) + top 3 suggestions avec score
- Badge "Recommandé" sur la meilleure suggestion

### Section 3 : Catalogue complet
- Tableau triable : nom, provider, prix input, prix output, contexte, tools, reasoning
- Filtres : provider, prix max, contexte min, tools only, reasoning only
- Recherche texte
- 342+ lignes avec pagination ou virtualisation

### Section 4 : Métadonnées
- Dernier refresh : date + nombre de modèles
- Bouton "Rafraîchir maintenant"

---

## Bloc 6 — Briefing hebdo coûts

Tâche récurrente pré-créée au premier boot (seed dans `initDatabase`) :

```
title: "Briefing hebdo coûts LLM"
cron_expression: "0 8 * * 1"  (lundi 8h)
cron_prompt: "Génère un résumé des coûts LLM de la dernière semaine. Inclus : total dépensé, top 3 modèles par coût, top 3 task types par coût, et suggestions d'optimisation si des modèles moins chers pourraient convenir. Format concis."
model: (auto-assigné par classification — probablement Haiku)
channel: "whatsapp"
```

L'utilisateur peut modifier la fréquence, le prompt, le canal, ou désactiver comme n'importe quelle tâche récurrente.

---

## Fichiers impactés

### Nouveaux fichiers
- `packages/agent/src/llm/catalog.ts` — fetch, cache, scoring
- `packages/agent/src/notifications/engine.ts` — moteur de notifications
- `packages/dashboard/app/models/page.tsx` — page catalogue + routing
- `packages/dashboard/app/settings/notifications/page.tsx` — config notifications

### Fichiers modifiés
- `packages/agent/src/llm/pricing.ts` — supprime PRICING hardcodé, lit depuis SQLite
- `packages/agent/src/llm/router.ts` — lit routes depuis `llm_route_config`
- `packages/agent/src/memory/sqlite.ts` — 4 nouvelles tables + migrations
- `packages/agent/src/server.ts` — ~10 nouveaux endpoints
- `packages/agent/src/tasks/cron.ts` — CRON refresh catalog daily
- `packages/agent/src/subagents/tasks.ts` — classification LLM à la création
- `packages/dashboard/app/costs/page.tsx` — refonte complète
- `packages/dashboard/app/components/sidebar.tsx` — ajout Models + Settings
- `packages/dashboard/app/components/notification-bell.tsx` — nouveau composant header
- `packages/dashboard/app/lib/api.ts` — helpers catalog, routes, notifications
- `packages/dashboard/app/globals.css` — styles nouvelles pages

---

## Vérification

1. `pnpm --filter @makilab/agent test` — tous les tests passent
2. `POST /api/models/refresh` → 342+ modèles en base
3. `GET /api/models/catalog?tools=true` → liste filtrée
4. `GET /api/models/routes` → 6 routes avec suggestions top 3
5. `PATCH /api/models/routes/classification` → change le modèle
6. Créer une tâche récurrente → modèle auto-assigné
7. `/costs` → stat cards + graphe + breakdowns + économies
8. `/models` → catalogue + routing + suggestions
9. Cloche notification → badge + dropdown
10. `/settings/notifications` → toggle canaux + quiet hours
11. `pnpm --filter @makilab/dashboard build` — build OK
