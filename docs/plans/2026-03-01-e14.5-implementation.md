# E14.5 â€” Smart Model Catalog + Notifications â€” Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Replace hardcoded LLM pricing/routing with a dynamic OpenRouter catalog, add a notification engine, and enrich the dashboard with /costs and /models pages.

**Architecture:** Fetch OpenRouter API â†’ cache in SQLite â†’ scoring engine recommends models per task type â†’ notification engine dispatches alerts â†’ dashboard pages for monitoring and configuration.

**Tech Stack:** Node.js 24, TypeScript, SQLite (node:sqlite), Fastify, Next.js 15, OpenRouter REST API

**Design doc:** `docs/plans/2026-03-01-e14.5-smart-catalog-notifications-design.md`

---

### Task 1: SQLite migrations â€” 4 new tables

**Files:**
- Modify: `packages/agent/src/memory/sqlite.ts`

**Step 1: Add migration functions**

Add 4 migrations after `migrateTasksAddModel(db)` in `initSchema()`:

```typescript
migrateLlmModels(db);
migrateLlmRouteConfig(db);
migrateNotifications(db);
migrateNotificationSettings(db);
```

Migration `migrateLlmModels`:
```sql
CREATE TABLE IF NOT EXISTS llm_models (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  provider_slug TEXT NOT NULL,
  context_length INTEGER NOT NULL,
  price_input_per_m REAL NOT NULL,
  price_output_per_m REAL NOT NULL,
  supports_tools INTEGER NOT NULL DEFAULT 0,
  supports_reasoning INTEGER NOT NULL DEFAULT 0,
  modality TEXT NOT NULL DEFAULT 'text->text',
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);
CREATE INDEX IF NOT EXISTS idx_llm_models_provider ON llm_models(provider_slug);
```

Migration `migrateLlmRouteConfig`:
```sql
CREATE TABLE IF NOT EXISTS llm_route_config (
  task_type TEXT PRIMARY KEY,
  model_id TEXT NOT NULL,
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);
```

Seed default routes:
```typescript
const defaults = [
  ['conversation', 'claude-sonnet-4-6'],
  ['compaction', 'claude-haiku-4-5-20251001'],
  ['fact_extraction', 'claude-haiku-4-5-20251001'],
  ['classification', 'google/gemini-2.0-flash-001'],
  ['cron_task', 'claude-sonnet-4-6'],
  ['orchestration', 'claude-haiku-4-5-20251001'],
];
for (const [tt, mid] of defaults) {
  db.prepare("INSERT OR IGNORE INTO llm_route_config (task_type, model_id) VALUES (?, ?)").run(tt, mid);
}
```

Migration `migrateNotifications`:
```sql
CREATE TABLE IF NOT EXISTS notifications (
  id TEXT PRIMARY KEY,
  type TEXT NOT NULL,
  severity TEXT NOT NULL DEFAULT 'info',
  title TEXT NOT NULL,
  body TEXT NOT NULL,
  link TEXT,
  read INTEGER NOT NULL DEFAULT 0,
  created_at TEXT NOT NULL DEFAULT (datetime('now'))
);
CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read, created_at DESC);
```

Migration `migrateNotificationSettings`:
```sql
CREATE TABLE IF NOT EXISTS notification_settings (
  channel TEXT PRIMARY KEY,
  enabled INTEGER NOT NULL DEFAULT 1,
  types_filter TEXT,
  quiet_hours_start TEXT,
  quiet_hours_end TEXT,
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);
```

Seed defaults:
```typescript
const channelDefaults = [
  ['mission_control', 1, null, null, null],
  ['whatsapp', 1, '["task_failure","system_alert"]', '22:00', '08:00'],
  ['email', 0, null, null, null],
];
for (const [ch, en, tf, qs, qe] of channelDefaults) {
  db.prepare("INSERT OR IGNORE INTO notification_settings (channel, enabled, types_filter, quiet_hours_start, quiet_hours_end) VALUES (?, ?, ?, ?, ?)").run(ch, en, tf, qs, qe);
}
```

**Step 2: Add CRUD functions for new tables**

Export from sqlite.ts:
- `upsertLlmModel(model: LlmModelRow): void`
- `getLlmModels(filters?: { tools?: boolean; minContext?: number; provider?: string }): LlmModelRow[]`
- `getLlmModel(id: string): LlmModelRow | null`
- `getLlmModelsCount(): number`
- `getLlmModelLastUpdate(): string | null`
- `getRouteConfig(): Array<{ task_type: string; model_id: string }>`
- `getRouteForTaskType(taskType: string): string | null`
- `setRouteForTaskType(taskType: string, modelId: string): void`
- `createNotification(n: { type: string; severity: string; title: string; body: string; link?: string }): string`
- `getNotifications(opts?: { unreadOnly?: boolean; limit?: number }): NotificationRow[]`
- `getUnreadNotificationCount(): number`
- `markNotificationRead(id: string): void`
- `markAllNotificationsRead(): void`
- `getNotificationSettings(): NotificationSettingRow[]`
- `updateNotificationSettings(channel: string, fields: Partial<NotificationSettingRow>): void`

**Step 3: Write tests**

File: `packages/agent/src/memory/__tests__/sqlite-catalog.test.ts`

Test: upsert model â†’ getLlmModels returns it, filtered queries work, route config CRUD, notification CRUD, settings CRUD.

**Step 4: Run tests**

Run: `pnpm --filter @makilab/agent test`

**Step 5: Commit**

```bash
git add packages/agent/src/memory/sqlite.ts packages/agent/src/memory/__tests__/sqlite-catalog.test.ts
git commit -m "feat(E14.5): SQLite migrations â€” llm_models, llm_route_config, notifications, notification_settings"
```

---

### Task 2: Catalog module â€” fetch + cache + scoring

**Files:**
- Create: `packages/agent/src/llm/catalog.ts`
- Test: `packages/agent/src/llm/__tests__/catalog.test.ts`

**Step 1: Implement catalog.ts**

```typescript
export interface CatalogFilter {
  tools?: boolean;
  reasoning?: boolean;
  minContext?: number;
  maxPriceInput?: number;
  provider?: string;
  search?: string;
}

export interface ModelScore {
  modelId: string;
  score: number;
  priceInput: number;
  priceOutput: number;
}

// Fetch from OpenRouter public API + upsert into SQLite
export async function refreshCatalog(): Promise<number>;

// Also insert Anthropic models (not on OpenRouter)
function seedAnthropicModels(): void;

// Init: refresh if cache empty or stale (>24h)
export async function initCatalog(): Promise<void>;

// Score models for a task type â€” returns top N
export function scoreModelsForTask(taskType: TaskType, topN?: number): ModelScore[];

// Get optimization suggestions: current route vs best alternative
export function getOptimizationSuggestions(): Array<{
  taskType: string;
  currentModel: string;
  currentPriceIn: number;
  currentPriceOut: number;
  suggestedModel: string;
  suggestedPriceIn: number;
  suggestedPriceOut: number;
  savingsPercent: number;
}>;
```

Scoring formula:
- Filter: supports_tools if task needs it, context >= 32K, text modality, price > 0 (skip free/unstable)
- Score = `1 / (price_input + price_output + 0.01)` Ã— capability bonus
- Bonus: +50% if reasoning support for complex tasks, +20% if context >= 200K

`seedAnthropicModels()` inserts claude-opus-4-6, claude-sonnet-4-6, claude-haiku-4-5-20251001 with known prices, marked `provider_slug = 'anthropic'`.

**Step 2: Write tests**

Test with mocked fetch (mock OpenRouter response with 5 models). Test scoring returns sorted by score. Test optimization suggestions.

**Step 3: Run tests, commit**

```bash
git commit -m "feat(E14.5): catalog module â€” fetch OpenRouter, cache SQLite, scoring engine"
```

---

### Task 3: Refactor pricing.ts + router.ts to use SQLite

**Files:**
- Modify: `packages/agent/src/llm/pricing.ts`
- Modify: `packages/agent/src/llm/router.ts`
- Test: `packages/agent/src/llm/__tests__/router.test.ts` (update existing if any)

**Step 1: Refactor pricing.ts**

Remove hardcoded `PRICING` dict. Replace with:

```typescript
import { getLlmModel, getLlmModels } from '../memory/sqlite.ts';

export function getModelPrice(model: string): { input: number; output: number } | null {
  const m = getLlmModel(model);
  if (!m) return null;
  return { input: m.price_input_per_m, output: m.price_output_per_m };
}

export function calculateCost(model: string, tokensIn: number, tokensOut: number): number {
  const price = getModelPrice(model);
  if (!price) return 0;
  return (tokensIn * price.input + tokensOut * price.output) / 1_000_000;
}

export function listAvailableModels(): Array<{ id: string; label: string; provider: string }> {
  return getLlmModels({ tools: true })
    .filter(m => m.modality.includes('text'))
    .map(m => ({ id: m.id, label: m.name, provider: m.provider_slug }));
}
```

**Step 2: Refactor router.ts**

Replace `DEFAULT_ROUTES` with SQLite lookup:

```typescript
import { getRouteForTaskType } from '../memory/sqlite.ts';

const FALLBACK_ROUTES: Record<TaskType, ModelRoute> = {
  // Keep as fallback if DB not initialized yet
  conversation:    { provider: 'anthropic', model: 'claude-sonnet-4-6' },
  compaction:      { provider: 'anthropic', model: 'claude-haiku-4-5-20251001' },
  fact_extraction: { provider: 'anthropic', model: 'claude-haiku-4-5-20251001' },
  classification:  { provider: 'openrouter', model: 'google/gemini-2.0-flash-001' },
  cron_task:       { provider: 'anthropic', model: 'claude-sonnet-4-6' },
  orchestration:   { provider: 'anthropic', model: 'claude-haiku-4-5-20251001' },
};

export function resolveModel(taskType: TaskType, modelOverride?: string): ModelRoute {
  if (modelOverride) {
    return { provider: inferProvider(modelOverride), model: modelOverride };
  }

  const dbModel = getRouteForTaskType(taskType);
  if (dbModel) {
    const route = { provider: inferProvider(dbModel), model: dbModel };
    if (route.provider === 'openrouter' && !config.openrouterApiKey) {
      return { provider: 'anthropic', model: 'claude-haiku-4-5-20251001' };
    }
    return route;
  }

  const fallback = FALLBACK_ROUTES[taskType];
  if (fallback.provider === 'openrouter' && !config.openrouterApiKey) {
    return { provider: 'anthropic', model: 'claude-haiku-4-5-20251001' };
  }
  return fallback;
}
```

**Step 3: Run all tests**

Run: `pnpm --filter @makilab/agent test`
Ensure existing tests still pass (pricing + router behavior unchanged for default routes).

**Step 4: Commit**

```bash
git commit -m "refactor(E14.5): pricing.ts + router.ts read from SQLite catalog"
```

---

### Task 4: Notification engine

**Files:**
- Create: `packages/agent/src/notifications/engine.ts`
- Test: `packages/agent/src/notifications/__tests__/engine.test.ts`

**Step 1: Implement engine.ts**

```typescript
import { createNotification, getNotificationSettings } from '../memory/sqlite.ts';
import { logger } from '../logger.ts';

export interface NotificationPayload {
  type: string;
  severity: 'info' | 'warning' | 'critical';
  title: string;
  body: string;
  link?: string;
}

export async function notify(payload: NotificationPayload): Promise<void> {
  // 1. Always store in DB (for mission_control bell)
  const id = createNotification({
    type: payload.type,
    severity: payload.severity,
    title: payload.title,
    body: payload.body,
    link: payload.link,
  });

  // 2. Dispatch to other channels
  const settings = getNotificationSettings();
  for (const setting of settings) {
    if (!setting.enabled || setting.channel === 'mission_control') continue;

    // Check type filter
    if (setting.types_filter) {
      const allowed = JSON.parse(setting.types_filter) as string[];
      if (!allowed.includes(payload.type)) continue;
    }

    // Check quiet hours
    if (isQuietHours(setting.quiet_hours_start, setting.quiet_hours_end)) continue;

    // Dispatch
    try {
      if (setting.channel === 'whatsapp') {
        await dispatchWhatsApp(payload);
      } else if (setting.channel === 'email') {
        await dispatchEmail(payload);
      }
    } catch (err) {
      logger.warn({ channel: setting.channel, err: err instanceof Error ? err.message : String(err) }, 'Notification dispatch failed');
    }
  }

  logger.info({ type: payload.type, id }, 'Notification created');
}

function isQuietHours(start: string | null, end: string | null): boolean {
  if (!start || !end) return false;
  const now = new Date();
  const hhmm = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
  if (start <= end) return hhmm >= start && hhmm < end;
  return hhmm >= start || hhmm < end; // overnight range
}

async function dispatchWhatsApp(payload: NotificationPayload): Promise<void> {
  // Will be connected when WhatsApp is unified in Fastify (E19)
  // For now: log only
  logger.info({ type: payload.type, title: payload.title }, 'WhatsApp notification (stub)');
}

async function dispatchEmail(payload: NotificationPayload): Promise<void> {
  // Stub â€” will use Gmail subagent
  logger.info({ type: payload.type, title: payload.title }, 'Email notification (stub)');
}
```

**Step 2: Write tests**

Test: notify() creates DB entry, type filter respected, quiet hours logic, dispatch stubs called.

**Step 3: Commit**

```bash
git commit -m "feat(E14.5): notification engine â€” create, store, dispatch with channel settings"
```

---

### Task 5: CRON catalog refresh + catalog init at boot

**Files:**
- Modify: `packages/agent/src/tasks/cron.ts` â€” add daily refresh job
- Modify: `packages/agent/src/server.ts` â€” call `initCatalog()` at boot

**Step 1: Add catalog refresh to cron.ts**

In `startCron()`, after the existing jobs:
```typescript
// Catalog refresh â€” daily at 3:00 AM
cron.schedule('0 3 * * *', async () => {
  logger.info({}, 'CRON: catalog refresh triggered');
  try {
    const { refreshCatalog } = await import('../llm/catalog.ts');
    const count = await refreshCatalog();
    logger.info({ count }, 'CRON: catalog refreshed');
  } catch (err) {
    logger.error({ err: err instanceof Error ? err.message : String(err) }, 'CRON: catalog refresh failed');
  }
});
```

**Step 2: Init catalog at server boot**

In `buildServer()` in server.ts, after CORS registration:
```typescript
import { initCatalog } from './llm/catalog.ts';
// Near the end, before return app:
await initCatalog();
```

**Step 3: Run tests, commit**

```bash
git commit -m "feat(E14.5): catalog init at boot + daily CRON refresh"
```

---

### Task 6: API endpoints â€” catalog, routes, notifications

**Files:**
- Modify: `packages/agent/src/server.ts`

**Step 1: Add catalog + routing endpoints**

```typescript
// GET /api/models/catalog â€” full catalog with filters
app.get<{ Querystring: { tools?: string; minContext?: string; provider?: string; search?: string } }>(
  '/api/models/catalog', async (req) => { ... }
);

// GET /api/models/routes â€” current routes + top 3 suggestions per task type
app.get('/api/models/routes', async () => { ... });

// PATCH /api/models/routes/:taskType â€” change model for a task type
app.patch<{ Params: { taskType: string }; Body: { model_id: string } }>(
  '/api/models/routes/:taskType', async (req) => { ... }
);

// POST /api/models/refresh â€” force catalog refresh
app.post('/api/models/refresh', async () => { ... });

// GET /api/models/suggestions â€” optimization suggestions
app.get('/api/models/suggestions', async () => { ... });
```

**Step 2: Add notification endpoints**

```typescript
// GET /api/notifications â€” list (query: ?unread=true&limit=20)
app.get<{ Querystring: { unread?: string; limit?: string } }>(
  '/api/notifications', async (req) => { ... }
);

// GET /api/notifications/count â€” { unread: N }
app.get('/api/notifications/count', async () => { ... });

// PATCH /api/notifications/:id â€” { read: true }
app.patch<{ Params: { id: string }; Body: { read: boolean } }>(
  '/api/notifications/:id', async (req) => { ... }
);

// POST /api/notifications/read-all
app.post('/api/notifications/read-all', async () => { ... });

// GET /api/notification-settings
app.get('/api/notification-settings', async () => { ... });

// PATCH /api/notification-settings/:channel
app.patch<{ Params: { channel: string }; Body: { enabled?: boolean; types_filter?: string[]; quiet_hours_start?: string | null; quiet_hours_end?: string | null } }>(
  '/api/notification-settings/:channel', async (req) => { ... }
);
```

**Step 3: Update existing GET /api/models**

Make it return the catalog (text models with tools support) instead of the hardcoded list. This is now just a proxy for `listAvailableModels()` which already reads from SQLite.

**Step 4: Run server test, commit**

```bash
git commit -m "feat(E14.5): API endpoints â€” catalog, routes, notifications, settings"
```

---

### Task 7: Task creation auto-model classification

**Files:**
- Create: `packages/agent/src/llm/classify-task.ts`
- Modify: `packages/agent/src/subagents/tasks.ts` â€” call classification on cron task create

**Step 1: Implement classify-task.ts**

```typescript
import { createLlmClient } from './client.ts';
import { scoreModelsForTask } from './catalog.ts';
import { logger } from '../logger.ts';

interface TaskClassification {
  complexity: 'simple' | 'moderate' | 'complex';
  sensitive: boolean;
  needsTools: boolean;
}

export async function classifyAndAssignModel(cronPrompt: string): Promise<string | null> {
  try {
    const client = createLlmClient();
    const response = await client.chat({
      taskType: 'classification',
      messages: [{ role: 'user', content: cronPrompt }],
      system: `Classify this recurring task prompt. Return JSON only:
{"complexity": "simple|moderate|complex", "sensitive": false, "needsTools": true}
- simple: reminders, summaries, status checks, short extractions
- moderate: analysis, multi-step reasoning, moderate writing
- complex: deep reasoning, long-form content, creative work
- sensitive: involves personal data, finances, emails
- needsTools: requires calling external tools/APIs`,
      maxTokens: 100,
    });

    const text = response.content.find(b => b.type === 'text')?.text ?? '';
    const parsed = JSON.parse(text) as TaskClassification;

    // Map to model using scoring
    if (parsed.sensitive) return 'claude-sonnet-4-6'; // Force Anthropic

    const taskType = parsed.needsTools
      ? (parsed.complexity === 'complex' ? 'conversation' : 'orchestration')
      : (parsed.complexity === 'complex' ? 'conversation' : 'classification');

    const scores = scoreModelsForTask(taskType, 1);
    return scores[0]?.modelId ?? null;
  } catch (err) {
    logger.warn({ err: err instanceof Error ? err.message : String(err) }, 'Task classification failed, skipping auto-model');
    return null;
  }
}
```

**Step 2: Hook into tasks subagent create action**

In `packages/agent/src/subagents/tasks.ts`, in the `create` action handler, after creating the task:
```typescript
if (input.cron_expression && input.cron_prompt) {
  const { classifyAndAssignModel } = await import('../llm/classify-task.ts');
  const model = await classifyAndAssignModel(input.cron_prompt);
  if (model) {
    updateTask(taskId, { model });
  }
}
```

**Step 3: Test + commit**

```bash
git commit -m "feat(E14.5): auto-classify recurring task prompt and assign optimal model"
```

---

### Task 8: Dashboard â€” notification bell component

**Files:**
- Create: `packages/dashboard/app/components/notification-bell.tsx`
- Modify: `packages/dashboard/app/layout.tsx` â€” add bell to header
- Modify: `packages/dashboard/app/lib/api.ts` â€” notification API helpers
- Modify: `packages/dashboard/app/globals.css` â€” notification styles

**Step 1: Add API helpers in api.ts**

```typescript
// Notifications
export interface NotificationInfo {
  id: string; type: string; severity: string; title: string;
  body: string; link: string | null; read: number; created_at: string;
}

export async function fetchNotifications(unread = false, limit = 20): Promise<NotificationInfo[]> { ... }
export async function fetchUnreadCount(): Promise<number> { ... }
export async function markNotificationRead(id: string): Promise<void> { ... }
export async function markAllNotificationsRead(): Promise<void> { ... }

// Catalog
export interface CatalogModel {
  id: string; name: string; provider_slug: string; context_length: number;
  price_input_per_m: number; price_output_per_m: number;
  supports_tools: number; supports_reasoning: number; modality: string;
}

export async function fetchCatalog(filters?: Record<string, string>): Promise<CatalogModel[]> { ... }
export async function fetchRoutes(): Promise<Array<{ task_type: string; model_id: string; suggestions: Array<{ modelId: string; score: number; priceInput: number; priceOutput: number }> }>> { ... }
export async function updateRoute(taskType: string, modelId: string): Promise<void> { ... }
export async function refreshCatalog(): Promise<{ count: number }> { ... }
export async function fetchOptimizationSuggestions(): Promise<Array<{ taskType: string; currentModel: string; suggestedModel: string; savingsPercent: number }>> { ... }

// Notification settings
export interface NotificationSettingInfo {
  channel: string; enabled: number; types_filter: string | null;
  quiet_hours_start: string | null; quiet_hours_end: string | null;
}
export async function fetchNotificationSettings(): Promise<NotificationSettingInfo[]> { ... }
export async function updateNotificationSettingsApi(channel: string, fields: Partial<NotificationSettingInfo>): Promise<void> { ... }
```

**Step 2: Implement notification-bell.tsx**

Bell icon in header with badge. Dropdown on click showing recent notifications. Click notification â†’ navigate to link. "Mark all read" button.

**Step 3: Update layout.tsx**

Add a header bar between Sidebar and main-content with the notification bell.

**Step 4: Add CSS styles**

Notification bell, dropdown, badge styles.

**Step 5: Commit**

```bash
git commit -m "feat(E14.5): notification bell component + API helpers"
```

---

### Task 9: Dashboard â€” /models page (catalog + routing + suggestions)

**Files:**
- Create: `packages/dashboard/app/models/page.tsx`
- Modify: `packages/dashboard/app/components/sidebar.tsx` â€” add Models link
- Modify: `packages/dashboard/app/globals.css` â€” models page styles

**Step 1: Implement models page**

3 sections:
1. **Optimization suggestions** â€” cards showing current vs recommended model with savings %
2. **Routing config** â€” 6 task type cards with model dropdown + top 3 suggestions
3. **Full catalog** â€” searchable/sortable/filterable table of all models

Features:
- Sort by: price, name, context, provider
- Filter: provider dropdown, tools checkbox, reasoning checkbox, price range
- Search: text search on name/id
- Pagination or virtual scroll for 342+ models

**Step 2: Update sidebar**

Add `{ href: '/models', label: 'Models', icon: 'ðŸ¤–' }` in MANAGE section, after Costs.

**Step 3: Add CSS**

Models page layout, catalog table, routing cards, suggestion cards.

**Step 4: Test dashboard build**

Run: `pnpm --filter @makilab/dashboard build`

**Step 5: Commit**

```bash
git commit -m "feat(E14.5): /models page â€” catalog, routing, optimization suggestions"
```

---

### Task 10: Dashboard â€” /costs page refonte

**Files:**
- Modify: `packages/dashboard/app/costs/page.tsx` â€” enrich existing page
- Modify: `packages/dashboard/app/globals.css` â€” cost page enhanced styles

**Step 1: Enhance costs page**

Add to existing page:
1. **Stat cards** â€” today / this week / this month with variation vs previous period
2. **Bar chart** â€” 30 days history (CSS-only bars, already partially exists)
3. **Breakdown by model** â€” horizontal bar chart
4. **Breakdown by task type** â€” horizontal bar chart
5. **Breakdown by channel** â€” horizontal bar chart (new API data needed: add `byChannel` to cost summary)
6. **Savings section** â€” link to /models suggestions

**Step 2: Update cost summary API**

Add `byChannel` breakdown to `/api/costs/summary` response.

**Step 3: Test build**

Run: `pnpm --filter @makilab/dashboard build`

**Step 4: Commit**

```bash
git commit -m "feat(E14.5): /costs page refonte â€” breakdowns, savings section"
```

---

### Task 11: Dashboard â€” /settings/notifications page

**Files:**
- Create: `packages/dashboard/app/settings/notifications/page.tsx`
- Modify: `packages/dashboard/app/components/sidebar.tsx` â€” add Settings section
- Modify: `packages/dashboard/app/globals.css` â€” settings styles

**Step 1: Implement notification settings page**

- Toggle per channel (mission_control, whatsapp, email)
- Type filter checkboxes per channel
- Quiet hours time pickers
- Save button per channel

**Step 2: Update sidebar**

Add SETTINGS section:
```typescript
{
  label: 'SETTINGS',
  items: [
    { href: '/settings/notifications', label: 'Notifications', icon: 'ðŸ””' },
  ],
},
```

**Step 3: Commit**

```bash
git commit -m "feat(E14.5): /settings/notifications page â€” channel config, quiet hours"
```

---

### Task 12: Cost optimization emitter + seed briefing task

**Files:**
- Create: `packages/agent/src/notifications/cost-emitter.ts`
- Modify: `packages/agent/src/tasks/cron.ts` â€” trigger cost check after catalog refresh

**Step 1: Implement cost-emitter.ts**

```typescript
import { getOptimizationSuggestions } from '../llm/catalog.ts';
import { notify } from './engine.ts';

export async function checkCostOptimizations(): Promise<void> {
  const suggestions = getOptimizationSuggestions();
  const significant = suggestions.filter(s => s.savingsPercent >= 30);

  if (significant.length === 0) return;

  const body = significant.map(s =>
    `${s.taskType}: ${s.currentModel} â†’ ${s.suggestedModel} (-${s.savingsPercent}%)`
  ).join('\n');

  await notify({
    type: 'cost_optimization',
    severity: 'info',
    title: `${significant.length} optimisation(s) de coÃ»ts disponible(s)`,
    body,
    link: '/models',
  });
}
```

**Step 2: Hook into CRON catalog refresh**

After `refreshCatalog()` completes, call `checkCostOptimizations()`.

**Step 3: Seed weekly briefing task**

In `initSchema()` or a dedicated seed function, create the recurring task if it doesn't exist:
```typescript
// Check if briefing task exists
const existing = db.prepare("SELECT id FROM tasks WHERE cron_id = 'weekly_cost_briefing'").get();
if (!existing) {
  // Create via createTask
  createTask({
    title: 'Briefing hebdo coÃ»ts LLM',
    createdBy: 'cron',
    channel: 'whatsapp',
    cronId: 'weekly_cost_briefing',
    cronExpression: '0 8 * * 1',
    cronPrompt: "GÃ©nÃ¨re un rÃ©sumÃ© des coÃ»ts LLM de la derniÃ¨re semaine. Inclus : total dÃ©pensÃ©, top 3 modÃ¨les par coÃ»t, top 3 task types par coÃ»t, et suggestions d'optimisation si des modÃ¨les moins chers pourraient convenir. Format concis.",
  });
}
```

**Step 4: Commit**

```bash
git commit -m "feat(E14.5): cost optimization emitter + weekly briefing seed task"
```

---

### Task 13: PROGRESS.md + verification

**Files:**
- Modify: `PROGRESS.md`

**Step 1: Update PROGRESS.md**

Add E14.5 section with all stories marked âœ….

**Step 2: Full verification**

Run:
1. `pnpm --filter @makilab/agent test` â€” all tests pass
2. `pnpm --filter @makilab/dashboard build` â€” builds OK
3. `pnpm dev:api` â€” start server, verify:
   - `curl localhost:3100/api/models/catalog | jq .length` â†’ 342+
   - `curl localhost:3100/api/models/routes` â†’ 6 routes with suggestions
   - `curl localhost:3100/api/notifications/count` â†’ `{ unread: N }`

**Step 3: Commit**

```bash
git commit -m "docs(E14.5): PROGRESS.md update + verification complete"
```

---

## Execution Summary

| Task | Description | Files |
|---|---|---|
| 1 | SQLite migrations (4 tables) + CRUD | sqlite.ts + test |
| 2 | Catalog module (fetch, cache, scoring) | catalog.ts + test |
| 3 | Refactor pricing.ts + router.ts | pricing.ts, router.ts |
| 4 | Notification engine | engine.ts + test |
| 5 | CRON refresh + boot init | cron.ts, server.ts |
| 6 | API endpoints (catalog, routes, notifs) | server.ts |
| 7 | Task auto-model classification | classify-task.ts, tasks.ts |
| 8 | Dashboard notification bell | bell component, layout, api.ts |
| 9 | Dashboard /models page | models/page.tsx, sidebar |
| 10 | Dashboard /costs refonte | costs/page.tsx |
| 11 | Dashboard /settings/notifications | settings page, sidebar |
| 12 | Cost emitter + briefing seed | cost-emitter.ts, cron.ts |
| 13 | PROGRESS.md + verification | PROGRESS.md |
